// replace any with dynamic?
// https://github.com/mrdoob/three.js/commit/fc70bb9ba7439148c10c9cb498793988d5cba899
// https://github.com/mrdoob/three.js/blob/fc70bb9ba7439148c10c9cb498793988d5cba899/build/three.js


interface THREE
{ 
	static attribute THREE.ColorUtilsType ColorUtils; 
	static attribute THREE.ImageUtilsType ImageUtils; 
	static attribute THREE.AnimationHandlerType AnimationHandler; 
	static attribute THREE.GeometryUtilsType GeometryUtils; 

	static attribute long DoubleSide; 
	static attribute long AdditiveBlending; 

    const long RepeatWrapping = 0;
    const long FaceColors = 1;
    const long LinearMipMapLinearFilter = 8;

};

// this is an anonymous type actually
interface THREE.GeometryUtilsType
{ 
	void merge(any x, any y);

};

// this is an anonymous type actually
interface THREE.ImageUtilsType
{ 
	THREE.Texture loadTexture(any src);
};

interface THREE.Texture
{ 
	attribute THREE.Vector2 repeat;
	
    attribute long wrapS;
    attribute long wrapT;
    attribute long magFilter;
    attribute long minFilter;
};



// this is an anonymous type actually
interface THREE.ColorUtilsType
{ 
	// no longer available [Obsolete]
	void adjustHSV(long color, long x, long y, double z);

};

interface THREE.AnimationHandlerType
{ 
	void add(any data);
	void update(double delta);

};

[Constructor(double x, double ratio, double a, double fov)]
interface THREE.PerspectiveCamera 
{ 
	attribute double aspect; 

	void updateProjectionMatrix();
	void lookAt(THREE.Vector3 target);
	void add(any e);

	attribute THREE.Vector3  position;
	attribute THREE.Vector3  up;

	attribute THREE.Matrix4  projectionMatrix;

	
};

[Constructor()]
interface THREE.Scene 
{ 
	attribute any         fog;
	//attribute THREE.Fog         fog;

	attribute THREE.Vector3  position;




	void add(any value);
	void remove(any value);
};



[Constructor(any parameters)]
interface THREE.ShaderMaterial 
{
};

[Constructor(long color)]
interface THREE.Color 
{ 
};


[Constructor(long x, long y)]
interface THREE.Plane 
{ 
};


// use dictionary instead? obsolete?
interface THREE.Raycaster_intersectObject
{
	attribute THREE.Vector3 point;
};

[Constructor]
interface THREE.Raycaster 
{ 
	void set(any position, any vec);
	sequence<THREE.Raycaster_intersectObject> intersectObject(THREE.Mesh position);
};


[Constructor(long color, double a)]
interface THREE.FogExp2
{
};

[Constructor(long color, long y, long z)]
interface THREE.Fog 
{ 
	// tested by X:\jsc.svn\examples\javascript\WebGLClouds\WebGLClouds\Application.cs

	attribute long        near;
	attribute long        far;


	attribute long        color;

};




[Constructor(long x), Constructor(long x, double y)]
interface THREE.DirectionalLight 
{ 
	attribute boolean        castShadow;


	attribute THREE.Vector3  position;
};

[Constructor(long x, double y, long z)]
interface THREE.PointLight 
{ 
	attribute THREE.Vector3  position;
};

[Constructor(long x, double y, double z)]
interface THREE.HemisphereLight 
{ 
	attribute THREE.Vector3  position;
};


[Constructor(long x)]
interface THREE.AmbientLight 
{ 
};

[Constructor(long x)]
interface THREE.SpotLight 
{ 
	attribute THREE.Vector3  position;
	attribute THREE.Object3D target;

	attribute boolean        castShadow;
	attribute long        shadowCameraNear;
	attribute long        shadowCameraFar;
	attribute long        shadowCameraFov;
	attribute double        shadowMapBias;
	attribute double        shadowMapDarkness;
	attribute long        shadowMapWidth;
	attribute long        shadowMapHeight;
};

[Constructor(long x, long y), 
	Constructor(long x, long y, long z, long q)]
interface THREE.PlaneGeometry 
{ 
	attribute sequence<THREE.Vector3>        vertices;

	void applyMatrix(any value);
};


[Constructor(), Constructor(double x, double y)]
interface THREE.Vector2
{ 
		attribute double x; 
	attribute double y;
};


[Constructor(), Constructor(double x, double y, double z)]
interface THREE.Vector3 
{ 
	attribute double x; 
	attribute double y;
	attribute double z;

	THREE.Vector3  set(double x, double y, double z);

	void copy( THREE.Vector3  p);
	void copy( any  p);
	THREE.Vector3  sub( THREE.Vector3   p);

	THREE.Vector3 subSelf(any xyz);
	THREE.Vector3 normalize();

	THREE.Vector3 getPositionFromMatrix(any m);
	THREE.Vector3 multiplyScalar(double m);

	double length();

};

[Constructor()]
interface THREE.Matrix4 
{ 
	any makePerspective(double fov, double xy, long a, long b);
	any makeRotationX(double value);

	// https://github.com/chandlerprall/Physijs/issues/91
	// stop breaking your library guys!
	// tested by X:\jsc.svn\examples\javascript\synergy\webgl\WebGLBossHarvesterByOutsideOfSociety\WebGLBossHarvesterByOutsideOfSociety\Application.cs
	any setRotationFromEuler(any vec3);
	any makeRotationFromEuler(any vec3);

	any setPosition(any vec3);
};

[Constructor(any x)]
interface THREE.MeshLambertMaterial 
{ 
	attribute long        color;
	attribute THREE.Texture map;
};

[Constructor()]
interface THREE.Object3D
{ 
	attribute THREE.Object3D  parent;

	attribute long        id;


	attribute THREE.Vector3  position;
	attribute THREE.Vector3  rotation;

	void add(any mesh);
};


[Constructor(any geometry, any material)]
interface THREE.Animation 
{ 
	attribute long        currentTime;

	void play();
};


[Constructor()]
interface THREE.Bone
{ 
	attribute THREE.Matrix4 skinMatrix;

	// object3D
	attribute sequence<THREE.Object3D>        children;
};



[Constructor(any mesh, any name)]
interface THREE.SkinnedMesh 
{ 
	attribute THREE.Vector3  rotation;
	attribute THREE.Vector3  position;


	attribute sequence<THREE.Bone>        bones;

};

[Constructor()]
interface THREE.Quaternion
{
	void copy( any  p);

};

[Constructor(any geometry), 
	Constructor(any geometry, any material)]
interface THREE.Mesh 
{ 
	attribute THREE.Vector3  rotation;
	attribute THREE.Vector3  position;
	attribute THREE.Vector3  scale;

	attribute THREE.Quaternion quaternion;
	attribute boolean visible;

	attribute boolean        castShadow;
	attribute boolean        receiveShadow;
	attribute boolean        useQuaternion;

	void lookAt(THREE.Vector3 target);
};

[Constructor(any geometry, any material)]
interface THREE.MorphAnimMesh 
{
	attribute THREE.Vector3  position;
	attribute THREE.Vector3  rotation;
	attribute THREE.Vector3  scale;
	attribute long duration;
	attribute long time;
	attribute long currentKeyframe;
	
	attribute boolean castShadow;
    attribute boolean receiveShadow;

	void updateAnimation(double delta);
	void setFrameRange(long animMin, long animMax);

};

[Constructor(), Constructor(any args)]
interface THREE.WebGLRenderer 
{ 
	attribute boolean        shadowMapEnabled;
	attribute boolean        shadowMapSoft;
	attribute boolean        autoClear;

	attribute Element domElement;


	void setClearColorHex(long color);
	void setClearColor(long color, long h);
	void setClearColor(THREE.Color color);
	void setSize(long w, long h);
	void render(any scene, any camera);

	void clear();
};

[Constructor(THREE.WebGLRenderer r)]
interface THREE.EffectComposer 
{ 
	void addPass(any e);
	void render(double e);

};

[Constructor]
interface THREE.Geometry 
{ 

};

[Constructor]
interface THREE.Face4 
{ 
	attribute THREE.Color        color;

};



[Constructor(double radius),
 Constructor(double size, double arg1, double arg2, double arg3, double arg4, double arg5),
 Constructor(double size, double arg1, double arg2, double arg3, double arg4, double arg5, double arg6)]
interface THREE.SphereGeometry 
{ 
	attribute sequence<THREE.Face4>        faces;

};

[Constructor(double size, double arg1, double arg2, double arg3)]
interface THREE.CylinderGeometry 
{ 
	void applyMatrix(any value);

};




[Constructor()]
interface THREE.Projector 
{ 
	void unprojectVector(any vector, any camera);
};


[Constructor(double x, double y, double z)]
interface THREE.CubeGeometry 
{ 
};

[Constructor(any position, any n)]
interface THREE.Ray 
{ 
	attribute THREE.Vector3  direction;
};

[Constructor(any geometry, any material)]
interface THREE.ParticleSystem 
{ 
	attribute THREE.Vector3  position;

};

[Constructor(any a)]
interface THREE.Sprite 
{ 
	attribute THREE.Vector3  position;
	attribute double  rotation;

};

[Constructor()]
interface THREE.JSONLoader 
{ 
	void load(any src, any handler);


};

[Constructor()]
interface THREE.MeshFaceMaterial 
{ 


};

[Constructor(any e)]
interface THREE.MeshBasicMaterial 
{ 


};


[Constructor(any e)]
interface THREE.MeshPhongMaterial 
{ 


};