// replace any with dynamic?


interface THREE
{ 
	static attribute THREE.ColorUtilsType ColorUtils; 
	

};

// this is an anonymous type actually
interface THREE.ColorUtilsType
{ 
	void adjustHSV(long color, long x, long y, double z);
	
};

[Constructor(double x, double ratio, double a, double fov)]
interface THREE.PerspectiveCamera 
{ 
	attribute double aspect; 
	void updateProjectionMatrix();

};

[Constructor()]
interface THREE.Scene 
{ 
	attribute THREE.Fog         fog;

	void add(any value);
};

[Constructor(long color, long y, long z)]
interface THREE.Fog 
{ 
	attribute long        color;
	
};

[Constructor(long x)]
interface THREE.AmbientLight 
{ 
};

[Constructor(long x)]
interface THREE.SpotLight 
{ 
	attribute THREE.Vector3  position;
	attribute THREE.Object3D target;

	attribute boolean        castShadow;
	attribute long        shadowCameraNear;
	attribute long        shadowCameraFar;
	attribute long        shadowCameraFov;
	attribute double        shadowMapBias;
	attribute double        shadowMapDarkness;
	attribute long        shadowMapWidth;
	attribute long        shadowMapHeight;
};

[Constructor(long x, long y, long z, long q)]
interface THREE.PlaneGeometry 
{ 
	void applyMatrix(any value);
};

[Constructor()]
interface THREE.Matrix4 
{ 
	any makeRotationX(double value);
};

[Constructor(any x)]
interface THREE.MeshLambertMaterial 
{ 
	attribute long        color;

};

[Constructor()]
interface THREE.Object3D
{ 
	attribute THREE.Vector3  position;
};


[Constructor(any geometry, any material)]
interface THREE.Mesh 
{ 
	attribute THREE.Vector3  position;
	attribute any quaternion;

	attribute boolean        castShadow;
	attribute boolean        receiveShadow;
	attribute boolean        useQuaternion;


};

[Constructor()]
interface THREE.WebGLRenderer 
{ 
	attribute boolean        shadowMapEnabled;
	attribute boolean        shadowMapSoft;

	attribute Element domElement;

	void setClearColor(long color, long h);
	void setSize(long w, long h);
	void render(any scene, any camera);
};

[Constructor(double radius)]
interface THREE.SphereGeometry 
{ 

};

[Constructor()]
interface THREE.Vector3 
{ 
	attribute double x; 
	attribute double y;
	attribute double z;

	void set(double x, double y, double z);

	THREE.Vector3 subSelf(any xyz);
	THREE.Vector3 normalize();

};

[Constructor()]
interface THREE.Projector 
{ 
	void unprojectVector(any vector, any camera);
};


[Constructor(double x, double y, double z)]
interface THREE.CubeGeometry 
{ 
};

[Constructor(any position, any n)]
interface THREE.Ray 
{ 
	attribute THREE.Vector3  direction;
};