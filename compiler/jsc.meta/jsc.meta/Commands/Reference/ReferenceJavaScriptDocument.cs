using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using jsc.Languages.IL;
using jsc.meta.Commands.Rewrite;
using jsc.meta.Library;
using jsc.meta.Tools;
using jsc.Script;
using Microsoft.CSharp;
using ScriptCoreLib;
using ScriptCoreLib.JavaScript;
using ScriptCoreLib.JavaScript.DOM;
using ScriptCoreLib.JavaScript.DOM.HTML;
using jsc.Library;
using ScriptCoreLib.Ultra.Library.Extensions;
using jsc.meta.Library.Templates.JavaScript;

namespace jsc.meta.Commands.Reference
{
	[Description("Injecting javascript into HTML has never been that easy!")]
	public partial class ReferenceJavaScriptDocument
	{


		public void Invoke()
		{
			var csproj = XDocument.Load(ProjectFileName.FullName);
			var csproj_dirty = false;



			/*

<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
	<RootNamespace>AutoGeneratedReferences</RootNamespace>

  <ItemGroup>
	<Reference Include="System" />

  <ItemGroup>
	<None Include="Components\JohDoe.TextComponent" />
			*/

			XNamespace ns = "http://schemas.microsoft.com/developer/msbuild/2003";
			var nsItemGroup = ns + "ItemGroup";
			var nsRootNamespace = ns + "RootNamespace";
			var nsPropertyGroup = ns + "PropertyGroup";
			var nsNone = ns + "None";
			var nsContent = ns + "Content";
			var nsDependentUpon = ns + "DependentUpon";
			var nsReference = ns + "Reference";
			var nsHintPath = ns + "HintPath";
			var nsAssemblyName = ns + "AssemblyName";

			var SourceAssemblyName = Enumerable.First(
				 from PropertyGroup in csproj.Root.Elements(nsPropertyGroup)
				 from AssemblyName in PropertyGroup.Elements(nsAssemblyName)
				 select AssemblyName.Value
			);

			var DefaultNamespace = Enumerable.First(
				 from PropertyGroup in csproj.Root.Elements(nsPropertyGroup)
				 from RootNamespace in PropertyGroup.Elements(nsRootNamespace)
				 select RootNamespace.Value
			);

			// bin is assumed to being ignored by svn
			// we need to stage it
			var Staging = this.ProjectFileName.Directory.CreateSubdirectory("bin/" + WebSource_HTML + ".staging");

			// fixme: no caching as of yet
			//var Cache = Staging.CreateSubdirectory("cache");

			#region AddReference
			Action<FileInfo, AssemblyName> AddReference =
				(AssemblyFile, Name) =>
				{

					/* add reference
<Reference Include="AutoGeneratedReferences.Components.JohDoe.TextComponent, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
  <SpecificVersion>False</SpecificVersion>
  <HintPath>bin\staging\AutoGeneratedReferences.Components.JohDoe.TextComponent.dll</HintPath>
</Reference>
					*/

					var TargetHintPath = AssemblyFile.FullName.Substring(ProjectFileName.Directory.FullName.Length + 1);

					if (!Enumerable.Any(
						 from ItemGroup in csproj.Root.Elements(nsItemGroup)
						 from Reference in ItemGroup.Elements(nsReference)
						 from HintPath in Reference.Elements(nsHintPath)
						 where TargetHintPath == HintPath.Value
						 select new { HintPath, Reference, ItemGroup }
						))
					{
						var TargetItemGroup = Enumerable.First(
							from ItemGroup in csproj.Root.Elements(nsItemGroup)
							from Reference in ItemGroup.Elements(nsReference)
							select ItemGroup
						);

						TargetItemGroup.Add(
							new XElement(nsReference,
								new XAttribute("Include", Name.ToString()),
								new XElement(nsHintPath, TargetHintPath)
							)
						);

						csproj_dirty = true;

					}
				};
			#endregion


			var Targets =
			  from ItemGroup in csproj.Root.Elements(nsItemGroup)
			  from None in ItemGroup.Elements(nsNone).Concat(ItemGroup.Elements(nsContent))
			  let Include = None.Attribute("Include").Value
			  let Directory = Path.GetDirectoryName(Include)


			  where DirectoryNeedsConversion(Directory)

			  let TargetName = DefaultNamespace + "." + Directory.Replace("/", ".").Replace("\\", ".")
			  let Target = new FileInfo(Path.Combine(Staging.FullName, TargetName.Substring(DefaultNamespace.Length + 1) + ".dll"))

			  let File = new FileInfo(Path.Combine(ProjectFileName.Directory.FullName, Include))
			  group new { ItemGroup, None, Include, File, Directory, TargetName, Target } by Directory;




			var References = Enumerable.Distinct(
				from k in Targets
				from f in k
				// should we restrict us to single file or allow multiple files to
				// enable grouping?
				where
					f.File.Name == __References
				from r in File.ReadAllLines(f.File.FullName)
				where !string.IsNullOrEmpty(r)
				select r
			);

			var LocalSources = Enumerable.ToArray(
				from k in Targets
				from f in k
				where f.File.Name.EndsWith(".htm")
				select new SourceFile
				{
					Content = File.ReadAllText(f.File.FullName),
					Reference = f.File.FullName,
					GetLocalResource =
						n =>
						{
							var r = k.SingleOrDefault(kk => kk.File.Name == n);

							if (r == null) return null;

							return r.File;
						}
				}
			);

			// http://support.microsoft.com/kb/304655
			var Sources = DownloadWebSource(References).Concat(LocalSources).ToArray();

			{
				var Product = DefaultNamespace + "." + WebSource_HTML;

				// at this time we are not actually merging anything...
				var r = default(RewriteToAssembly);

				r = new RewriteToAssembly
				{
					staging = Staging,
					product = Product,

					#region if we are going to inject code from jsc we need to copy it
					rename = new RewriteToAssembly.NamespaceRenameInstructions[] {
					    "jsc.meta->" +  DefaultNamespace,
					    "jsc->" +  DefaultNamespace,
					},

					//merge = new RewriteToAssembly.MergeInstruction[] {
					//    "jsc.meta",
					//    "jsc"
					//},
					#endregion

					PostRewrite =
						a =>
						{
							// at this point we are free to add any additional code here
							// maybe we should infer some cool classes?


							a.Assembly.DefineAttribute<ObfuscationAttribute>(
								new
								{
									Feature =
										this.IsMerge ? "merge" : "script"
								}
							);

							// Nested types do not play well with type erasure...

							//var Pages = a.Module.DefineType(DefaultNamespace + ".Pages", TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.Public);

							// http://www.w3schools.com/tags/ref_entities.asp
							// http://www.w3schools.com/HTML/html_entities.asp
							// http://stackoverflow.com/questions/281682/reference-to-undeclared-entity-exception-while-working-with-xml


							var TypeVariations = new Dictionary<string, TypeVariations>();


							foreach (var item in Sources)
							{
								// http://stackoverflow.com/questions/1039476/reference-to-undeclared-entity-nbsp-why
								// http://forums.asp.net/t/1219076.aspx

								// dirty fix..
								var content = item.Content;

								// http://blogs.pingpoet.com/overflow/archive/2005/07/20/6607.aspx
								// http://msdn.microsoft.com/en-us/library/bb356942.aspx
								// fixme: XmlReader + DTD

								// yet another fix
								const string doctype_ok = @"<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Strict//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"">";
								const string doctype_vs = @"<!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.0 Transitional//EN"">";

								if (content.StartsWith(doctype_vs))
									content = doctype_ok + content.Substring(doctype_vs.Length);

								content = HTMLEntities.Aggregate(content,
										 (i, k) => i.Replace(k.Key, k.Value)
								 );


								// really dirty fix...

								content = content.Replace("<html xmlns=\"http://www.w3.org/1999/xhtml\"", "<html ");

								//var reader = XmlReader.Create(new StringReader(content), new XmlReaderSettings { ProhibitDtd = false });
								//var xml = XDocument.Load(reader);
								////var nameTable = reader.NameTable;
								//var namespaceManager = new XmlNamespaceManager(nameTable);
								//namespaceManager.AddNamespace("", "http://www.w3.org/1999/xhtml");

								var xml = XDocument.Parse(content);
								// http://stackoverflow.com/questions/477962/how-to-create-xelement-with-default-namespace-for-children-without-using-xnamespa

								XNamespace xhtml = "http://www.w3.org/1999/xhtml";

								// For body and each class element
								var TitleElement = xml.XPathSelectElement("/html/head/title");
								var BodyElement = xml.XPathSelectElement("/html/body");

								var PageName = CompilerBase.GetSafeLiteral(TitleElement.Value, null);

								// we need to make the title/page name
								// C# compatible :)

								// The web application could opt in for dynamic CMS updates... RSS ? :) Download HTML on the server and push updates?


								DefineNamedImages(DefaultNamespace, a, BodyElement, r, item.GetLocalResource, TypeVariations.Add);

								WritePageType(DefaultNamespace, a, content, BodyElement, PageName, TypeVariations);


								var __id = BodyElement.XPathSelectElements("//*[@id]").Select(k => new { CurrentElement = k, id = k.Attribute("id").Value });

								foreach (var k in __id)
								{
									WritePageType(DefaultNamespace, a, null, k.CurrentElement, "Controls.Named." + PageName + "_" + k.id, TypeVariations);
								}

								var __class = BodyElement.XPathSelectElements("//*[@class]").Except(BodyElement.XPathSelectElements("//*[@id]")).Select(k => new { CurrentElement = k, @class = k.Attribute("class").Value }).Where(k => !k.@class.Contains(" ")).GroupBy(k => k.@class).Where(k => k.Count() == 1).Select(k => k.Single());

								foreach (var k in __class)
								{
									WritePageType(DefaultNamespace, a, null, k.CurrentElement, "Controls.Anonymous." + PageName + "_" + k.@class, TypeVariations);
								}

							}


							//Pages.CreateType();
						}
				};

				r.Invoke();

				AddReference(r.Output, new AssemblyName(Product));
			}

			if (csproj_dirty)
				csproj.Save(this.ProjectFileName.FullName);
		}

		private static bool DirectoryNeedsConversion(string Directory)
		{
			if (Directory == WebSource_HTML || Directory.EndsWith("." + WebSource_HTML) || Directory.EndsWith("\\" + WebSource_HTML))
				return true;

			if (Directory == UltraSource || Directory.EndsWith("." + UltraSource) || Directory.EndsWith("\\" + UltraSource))
				return true;

			return false;
		}


		private void WritePageType(
			string DefaultNamespace,
			RewriteToAssembly.AssemblyRewriteArguments a,
			string content,
			XElement BodyElement,
			string PageName,

			Dictionary<string, TypeVariations> TypeVariations
			)
		{
			var PageFullName = DefaultNamespace + ".HTML.Pages.FromWeb." + PageName;
			Console.WriteLine(PageFullName);

			var Page = a.Module.DefineType(PageFullName, TypeAttributes.Public);

			{
				var PropertyName = "Tag";
				var PropertyType = typeof(object);

				Page.DefineAutomaticProperty(PropertyName, PropertyType);
			}

			var Static = Page.DefineNestedType("Static", TypeAttributes.NestedPublic | TypeAttributes.Abstract | TypeAttributes.Sealed);


			// we should be returning DOM object instead?
			// should use DataNamespace instead?

			#region DocumentHTML
			if (content != null)
			{
				var Page_HTML = Static.DefineProperty("DocumentHTML", PropertyAttributes.None, typeof(string), null);

				var Page_HTML_get = Static.DefineMethod("get_DocumentHTML", MethodAttributes.Static | MethodAttributes.Public, typeof(string), null);

				{
					var il = Page_HTML_get.GetILGenerator();

					il.Emit(OpCodes.Ldstr, content);
					il.Emit(OpCodes.Ret);
				}

				Page_HTML.SetGetMethod(Page_HTML_get);
			}
			#endregion

			#region Page_HTML
			{
				var Page_HTML = Static.DefineProperty("HTML", PropertyAttributes.None, typeof(string), null);

				var Page_HTML_get = Static.DefineMethod("get_HTML", MethodAttributes.Static | MethodAttributes.Public, typeof(string), null);

				{
					var il = Page_HTML_get.GetILGenerator();

					// http://stackoverflow.com/questions/3793/best-way-to-get-innerxml-of-an-xelement
					var body_innerXML = BodyElement.Nodes().Aggregate("", (b, node) => b += node.ToString());

					il.Emit(OpCodes.Ldstr, body_innerXML);
					il.Emit(OpCodes.Ret);
				}

				Page_HTML.SetGetMethod(Page_HTML_get);
			}
			#endregion

			// we need to use unified HTML DOM...
			if (!this.IsGeneric)
			{
				// http://www.exampledepot.com/egs/org.w3c.dom/xpath_GetElemByAttr.html
				var Elements = Static.DefineNestedType("Elements", TypeAttributes.NestedPublic);

				var Images_value = BodyElement.XPathSelectElements("/img").ToArray();

				DefineStaticImages(a, Static, Images_value);



				foreach (var CurrentElement in BodyElement.XPathSelectElements("/*[@id]"))
				{
					var id = CurrentElement.Attribute("id").Value;

					var e_Type = ElementTypes.ContainsKey(CurrentElement.Name.LocalName) ? ElementTypes[CurrentElement.Name.LocalName] : typeof(IHTMLElement);

					var e = Elements.DefineProperty(id, PropertyAttributes.None, e_Type, null);
					var get_e = Elements.DefineMethod("get_" + id, MethodAttributes.Static | MethodAttributes.Public, e_Type, null);

					Func<IHTMLElement> get_e_template =
						delegate
						{
							return Native.Document.getElementById("id");
						};

					{
						var il = get_e.GetILGenerator();

						var il_a = new ILTranslationExtensions.EmitToArguments();

						il_a[OpCodes.Ldstr] =
							x =>
							{
								x.il.Emit(OpCodes.Ldstr, id);
							};

						il_a[OpCodes.Ret] =
							x =>
							{
								x.il.Emit(OpCodes.Castclass, e_Type);
								x.il.Emit(OpCodes.Ret);
							};

						get_e_template.Method.EmitTo(il, il_a);


					}

					e.SetGetMethod(get_e);
				}

				Elements.CreateType();

				var Images_lookup = new Dictionary<XElement, FieldBuilder>();

				foreach (var i in Images_value)
				{
					Images_lookup[i] = null;
				}


				DefinePageConstructor(BodyElement, Page, new[] { Images_lookup }, TypeVariations);

				// and html5 videos and sounds!
				DefineInstanceImages(a, Page, Images_lookup);

			}

			Static.CreateType();
			Page.CreateType();
		}

		private void DefineInstanceImages(RewriteToAssembly.AssemblyRewriteArguments a, TypeBuilder Page, Dictionary<XElement, FieldBuilder> lookup)
		{
			#region References
			var References = Page.DefineProperty("Images", PropertyAttributes.None, typeof(IHTMLImage[]), null);

			var References_get = Page.DefineMethod("get_Images", MethodAttributes.Public, typeof(IHTMLImage[]), null);

			References.SetGetMethod(References_get);

			{
				var il = References_get.GetILGenerator();

				Func<IHTMLImage[]> Implementation1 = () => new IHTMLImage[] { };

				var il_a = new ILTranslationExtensions.EmitToArguments();

				var Images = lookup.Where(k => k.Value != null).Select((k, index) => new { k, index }).ToArray();


				il_a[OpCodes.Ldc_I4_0] =
					x =>
					{
						il.Emit(OpCodes.Ldc_I4, Images.Length);
					};

				il_a[OpCodes.Stloc_0] =
					x =>
					{
						il.Emit(OpCodes.Stloc_0);

						foreach (var item in Images)
						{
							il.Emit(OpCodes.Ldloc_0);
							il.Emit(OpCodes.Ldc_I4, item.index);
							il.Emit(OpCodes.Ldarg_0);
							il.Emit(OpCodes.Ldfld, item.k.Value);
							il.Emit(OpCodes.Stelem_Ref);


							/*
							L_0007: ldloc.1 
							L_0008: ldc.i4.0 
							L_0009: ldstr ""
							L_000e: stelem.ref 
							 */
						}
					};



				Implementation1.Method.EmitTo(il, il_a);
			}
			#endregion

		}

		private void DefineStaticImages(RewriteToAssembly.AssemblyRewriteArguments a, TypeBuilder Page, XElement[] i)
		{
			if (i == null)
				throw new ArgumentNullException("i");
			//var Images = Page.DefineNestedType("Images", TypeAttributes.NestedPublic);

			var References_value = i
				.Where(k => k.Attribute("src") != null)
				.Select(k => k.Attribute("src").Value)
				.Where(k => !string.IsNullOrEmpty(k))
				.Distinct()
				.Select((k, index) => new { k, index })
				.ToArray();

			// we might want to return IHTMLImage references instead with or without id's...

			#region References
			var References = Page.DefineProperty("Images", PropertyAttributes.None, typeof(string[]), null);

			var References_get = Page.DefineMethod("get_Images", MethodAttributes.Public | MethodAttributes.Static, typeof(string[]), null);

			References.SetGetMethod(References_get);

			{
				var il = References_get.GetILGenerator();

				Func<string[]> Implementation1 = () => new string[] { };

				var il_a = new ILTranslationExtensions.EmitToArguments();



				il_a[OpCodes.Ldc_I4_0] =
					x =>
					{
						il.Emit(OpCodes.Ldc_I4, References_value.Length);
					};

				il_a[OpCodes.Stloc_0] =
					x =>
					{
						il.Emit(OpCodes.Stloc_0);

						foreach (var item in References_value)
						{
							il.Emit(OpCodes.Ldloc_0);
							il.Emit(OpCodes.Ldc_I4, item.index);
							il.Emit(OpCodes.Ldstr, item.k);
							il.Emit(OpCodes.Stelem_Ref);


							/*
							L_0007: ldloc.1 
							L_0008: ldc.i4.0 
							L_0009: ldstr ""
							L_000e: stelem.ref 
							 */
						}
					};



				Implementation1.Method.EmitTo(il, il_a);
			}
			#endregion

		}

		private static void DefinePageConstructor(
			XElement body,
			TypeBuilder Page,
			Dictionary<XElement, FieldBuilder>[] lookup,
			Dictionary<string, TypeVariations> TypeVariations
			)
		{
			var ctor = Page.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, null);
			var ElementType = typeof(IHTMLElement);

			var Container = Page.DefineField("_Container", ElementType, FieldAttributes.Private | FieldAttributes.InitOnly);

			var ElementProperty = Page.DefineProperty("Container", PropertyAttributes.None, ElementType, null);

			var get_ElementField = Page.DefineMethod("get_Container", MethodAttributes.Public, CallingConventions.Standard, ElementType, null);

			var get_ElementField_il = get_ElementField.GetILGenerator();

			get_ElementField_il.Emit(OpCodes.Ldarg_0);
			get_ElementField_il.Emit(OpCodes.Ldfld, Container);
			get_ElementField_il.Emit(OpCodes.Ret);

			ElementProperty.SetGetMethod(get_ElementField);


			var Counter = new Counter();

			{
				var il = ctor.GetILGenerator();

				DefinePageElement(body, Page, Counter, il, OpCodes.Ldnull, lookup, TypeVariations);

				#region this.Container = loc0
				il.Emit(OpCodes.Ldarg_0);
				il.Emit(OpCodes.Ldloc_0);
				il.Emit(OpCodes.Stfld, Container);
				#endregion

				il.Emit(OpCodes.Ret);
			}
		}

		public class Counter
		{
			public int Value;
		}

		private static void DefinePageElement(
			XElement body,
			TypeBuilder Page,
			Counter Counter,
			ILGenerator il,
			OpCode parent,
			Dictionary<XElement, FieldBuilder>[] lookup,
			Dictionary<string, TypeVariations> TypeVariations

			)
		{
			Action Implementation1 =
				delegate
				{
					var c = TemplateHolder.Initialize(null);
				};

			{
				var il_a = new ILTranslationExtensions.EmitToArguments();

				il_a[OpCodes.Call] = x =>
				{
					var Initialize = Page.DefineMethod(
						"Initialize_" + Counter.Value++,
						MethodAttributes.Family | MethodAttributes.Static,
						typeof(IHTMLElement),
						new[] { Page, typeof(IHTMLElement) }
					);

					DefinePageElement(body, Initialize.GetILGenerator(), Page, Counter, lookup, TypeVariations);

					x.il.Emit(OpCodes.Ldarg_0);
					x.il.Emit(parent);
					x.il.Emit(OpCodes.Call, Initialize);
				};

				il_a[OpCodes.Ret] = x => { };
				il_a[OpCodes.Ldnull] = x => { };

				Implementation1.Method.EmitTo(il, il_a);
			}
		}

		private static void DefinePageElement(
			XElement CurrentElement,
			ILGenerator il,
			TypeBuilder Page,
			Counter Counter,
			Dictionary<XElement, FieldBuilder>[] lookup,
			Dictionary<string, TypeVariations> TypeVariations

			)
		{
			var DefaultElementType =
				// ScriptCoreLib ElementType Lookup...
				(ElementTypes.ContainsKey(CurrentElement.Name.LocalName) ? ElementTypes[CurrentElement.Name.LocalName] : typeof(IHTMLElement));

			var ElementType = DefaultElementType;

			if (ElementType == typeof(IHTMLImage))
			{
				CurrentElement.Attribute("src").Apply(
					src =>
					{
						var v = TypeVariations[src.Value];

						ElementType = v.FromWeb ?? v.FromBase64;
					}
				);
			}


			Action Continuation1 =
				delegate
				{
					// http://www.456bereastreet.com/archive/200412/the_alt_and_title_attributes/

					var Element__id = CurrentElement.Attribute("id") ?? CurrentElement.Attribute("alt");
					var ElementHasId = Element__id != null;
					var ElementInLookup = lookup.Any(k => k.Keys.Contains(CurrentElement));

					if (ElementHasId || ElementInLookup)
					{


						var ElementField = Page.DefineField("_" + (Element__id == null ? "" + Counter.Value++ : Element__id.Value), ElementType, FieldAttributes.Private);

						foreach (var k in
							from k0 in lookup
							where k0.ContainsKey(CurrentElement)
							select k0
							)
						{
							k[CurrentElement] = ElementField;
						}

						il.Emit(OpCodes.Ldarg_0);
						il.Emit(OpCodes.Ldloc_0);
						il.Emit(OpCodes.Castclass, ElementType);
						il.Emit(OpCodes.Stfld, ElementField);

						if (ElementHasId)
						{
							var ElementPropertyName = CompilerBase.GetSafeLiteral(
									Element__id.Value, null
								);

							var ElementProperty = Page.DefineProperty(
								ElementPropertyName, PropertyAttributes.None, ElementType, null);

							var get_ElementField = Page.DefineMethod("get_" + ElementPropertyName, MethodAttributes.Public, CallingConventions.Standard, ElementType, null);

							var get_ElementField_il = get_ElementField.GetILGenerator();

							get_ElementField_il.Emit(OpCodes.Ldarg_0);
							get_ElementField_il.Emit(OpCodes.Ldfld, ElementField);
							get_ElementField_il.Emit(OpCodes.Ret);

							ElementProperty.SetGetMethod(get_ElementField);
						}
					}


					#region c.setAttribute("name", "value");
					Action<IHTMLElement> Implementation3 =
						c =>
						{
							// seems to work for .style too in browsers :)
							c.setAttribute("name", "value");
						};




					foreach (var item in CurrentElement.Attributes())
					{
						if (item.Name.LocalName == "id")
							continue;

						if (DefaultElementType == typeof(IHTMLImage) && item.Name == "src")
							continue;

						var il_a = new ILTranslationExtensions.EmitToArguments();

						il_a[OpCodes.Ret] = delegate { };
						il_a[OpCodes.Ldarg_0] = x => x.il.Emit(OpCodes.Ldloc_0);
						il_a[OpCodes.Ldstr] = x => x.il.Emit(OpCodes.Ldstr,
							x.i.TargetLiteral == "name" ? item.Name.LocalName : item.Value
						);

						Implementation3.Method.EmitTo(il, il_a);

					}
					#endregion

					#region c.appendChild
					Action<IHTMLElement> Implementation4 =
						c =>
						{
							c.appendChild(new ITextNode("e"));
						};

					foreach (var item in CurrentElement.Nodes())
					{
						if (item is XText)
						{
							var il_a = new ILTranslationExtensions.EmitToArguments();

							il_a[OpCodes.Ret] = delegate { };
							il_a[OpCodes.Ldarg_0] = x => x.il.Emit(OpCodes.Ldloc_0);
							il_a[OpCodes.Ldstr] = x => x.il.Emit(OpCodes.Ldstr, ((XText)item).Value);

							Implementation4.Method.EmitTo(il, il_a);
						}

						if (item is XElement)
						{
							DefinePageElement((XElement)item, Page, Counter, il, OpCodes.Ldloc_0, lookup, TypeVariations);
						}
					}
					#endregion
				};

			{
				#region Implementation1
				Func<object, IHTMLElement, IHTMLElement> Implementation1 =
					(__this, parent) =>
					{
						var c = new IHTMLElement("" /* body.Name.LocalName */);

						//c.setAttribute("title", "hi");
						TemplateHolder.Implementation();



						if (parent != null)
							parent.appendChild(c);

						return c;
					};

				Func<object, IHTMLElement, IHTMLElement> Implementation2 =
						(__this, parent) =>
						{
							var c = new NamedImage();

							//c.setAttribute("title", "hi");
							TemplateHolder.Implementation();



							if (parent != null)
								parent.appendChild(c);

							return c;
						};

				{
					var il_a = new ILTranslationExtensions.EmitToArguments
					{
						TranslateTargetType =
							SourceType =>
							{
								if (ElementType != DefaultElementType)
									if (SourceType == typeof(NamedImage))
										return ElementType;

								return SourceType;
							},

						TranslateTargetConstructor =
							SourceConstructor =>
							{
								if (ElementType != DefaultElementType)
									if (SourceConstructor.DeclaringType == typeof(NamedImage))
										return ElementType.GetConstructor(new Type[0]);

								return SourceConstructor;
							}
					};

					il_a[OpCodes.Call] = x =>
					{
						Action Implementation = TemplateHolder.Implementation;
						if (x.i.TargetMethod == Implementation.Method)
						{
							Continuation1();

							return;
						}

						il.Emit(OpCodes.Call, x.i.TargetMethod);
					};

					il_a[OpCodes.Ldarg_0] = x => x.il.Emit(OpCodes.Ldarg_1);
					il_a[OpCodes.Ldstr] = x => x.il.Emit(OpCodes.Ldstr, CurrentElement.Name.LocalName);

					if (DefaultElementType == typeof(IHTMLImage))
						Implementation2.Method.EmitTo(il, il_a);
					else
						Implementation1.Method.EmitTo(il, il_a);
				}
				#endregion
			}
		}

		static class TemplateHolder
		{
			public static IHTMLElement Initialize(IHTMLElement e)
			{
				return null;
			}


			public static void Implementation()
			{
			}
		}


		public class SourceFile
		{
			public string Reference;
			public string Content;

			public Func<string, FileInfo> GetLocalResource;
		}

		private static IEnumerable<SourceFile> DownloadWebSource(IEnumerable<string> References)
		{
			foreach (var Reference in References)
			{
				Console.WriteLine("downloading: " + Reference);

				var c = (HttpWebRequest)HttpWebRequest.Create(Reference);

				// http://code.logos.com/blog/2009/06/using_if-modified-since_in_http_requests.html
				// http://msdn.microsoft.com/en-us/library/system.net.httpwebrequest.ifmodifiedsince.aspx
				// http://www.acmebinary.com/blog/archive/2006/09/05/252.aspx

				var r = (HttpWebResponse)c.GetResponse();

				try
				{
					if (r.StatusCode == HttpStatusCode.OK)
					{
						var Content = new StreamReader(r.GetResponseStream()).ReadToEnd();

						yield return new SourceFile { Content = Content, Reference = Reference };
					}

				}
				finally
				{
					r.Close();
				}

			}
		}

		// http://www.w3.org/TR/REC-html40/sgml/entities.html
		public static readonly Dictionary<string, string> HTMLEntities = new Dictionary<string, string>
							{
								{"&nbsp;", "&#160;"},
								{"&ndash;", "&#8211;"},
								{"&laquo;", "&#171;"},
								{"&raquo;", "&#187;"},
							};

		// this should be part of the ScriptCoreLib

		// todo: we should actually scan the html elements for InternalConstructos and infer the type names!

		public static readonly Dictionary<string, Type> ElementTypes = new Dictionary<string, Type>
							{
								{"a", typeof(IHTMLAnchor)},
								{"img", typeof(IHTMLImage)},
								{"textarea", typeof(IHTMLTextArea)},
								{"input", typeof(IHTMLInput)},
								{"button", typeof(IHTMLButton)},
								{"label", typeof(IHTMLLabel)},
								{"iframe", typeof(IHTMLIFrame)},
							};


	}
}
