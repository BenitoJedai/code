using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Reflection;
using System.Reflection.Emit;
using jsc.meta.Library;
using System.Runtime.CompilerServices;

namespace jsc.meta.Commands
{
	public class ReferenceTextComponent
	{
		const string TextComponent = "TextComponent";

		// this is an example of how jsc.meta
		// could be used as a code generator
		// before any jsc kicks in

		public FileInfo ProjectFileName;

		public void Invoke()
		{
			var csproj = XDocument.Load(ProjectFileName.FullName);
			var csproj_dirty = false;



			/*

<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
	<RootNamespace>AutoGeneratedReferences</RootNamespace>

  <ItemGroup>
	<Reference Include="System" />

  <ItemGroup>
	<None Include="Components\JohDoe.TextComponent" />
			*/

			XNamespace ns = "http://schemas.microsoft.com/developer/msbuild/2003";
			var nsItemGroup = ns + "ItemGroup";
			var nsRootNamespace = ns + "RootNamespace";
			var nsPropertyGroup = ns + "PropertyGroup";
			var nsNone = ns + "None";
			var nsDependentUpon = ns + "DependentUpon";
			var nsReference = ns + "Reference";
			var nsHintPath = ns + "HintPath";

			var DefaultNamespace = Enumerable.First(
				 from PropertyGroup in csproj.Root.Elements(nsPropertyGroup)
				 from RootNamespace in PropertyGroup.Elements(nsRootNamespace)
				 select RootNamespace.Value
			);

			// bin is assumed to being ignored by svn
			// we need to stage it
			var Staging = this.ProjectFileName.Directory.CreateSubdirectory("bin/" + TextComponent + ".staging");

			#region take 1 - single file to single assembly
			foreach (var h in
			  from ItemGroup in csproj.Root.Elements(nsItemGroup)
			  from None in ItemGroup.Elements(nsNone)
			  let Include = None.Attribute("Include").Value
			  where Include.EndsWith("." + TextComponent)
			  let TargetName = DefaultNamespace + "." + Include.Replace("/", ".").Replace("\\", ".")
			  let Target = new FileInfo(Path.Combine(Staging.FullName, TargetName.Substring(DefaultNamespace.Length + 1) + ".dll"))
			  let File = new FileInfo(Path.Combine(ProjectFileName.Directory.FullName, Include))
			  select new { ItemGroup, None, Include, File, TargetName, Target }
			  )
			{



				// we should skip this step if source is not newer than the product!
				GenerateAssembly(h.Target, h.TargetName, Staging, new [] { h.File },
					Name =>
					{

						/* add reference
  <Reference Include="AutoGeneratedReferences.Components.JohDoe.TextComponent, Version=0.0.0.0, Culture=neutral, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\staging\AutoGeneratedReferences.Components.JohDoe.TextComponent.dll</HintPath>
    </Reference>
						*/

						var TargetHintPath = h.Target.FullName.Substring(ProjectFileName.Directory.FullName.Length + 1);

						if (!Enumerable.Any(
							 from ItemGroup in csproj.Root.Elements(nsItemGroup)
							 from Reference in ItemGroup.Elements(nsReference)
							 from HintPath in Reference.Elements(nsHintPath)
							 where TargetHintPath == HintPath.Value
							 select new { HintPath, Reference, ItemGroup }
							))
						{
							var TargetItemGroup = Enumerable.First(
								from ItemGroup in csproj.Root.Elements(nsItemGroup)
								from Reference in ItemGroup.Elements(nsReference)
								select ItemGroup
							);

							TargetItemGroup.Add(
								new XElement(nsReference,
									new XAttribute("Include", Name.ToString()),
									new XElement(nsHintPath, TargetHintPath)
								)
							);

							csproj_dirty = true;

						}
					}
				);


			}
			#endregion

			#region take 2 - multiple files to single assembly
			#endregion

			foreach (var k in
				from ItemGroup in csproj.Root.Elements(nsItemGroup)
				from Reference in ItemGroup.Elements(nsReference)
				from HintPath in Reference.Elements(nsHintPath)
				let HintPathFile = new FileInfo(Path.Combine(ProjectFileName.Directory.FullName, HintPath.Value))
				where HintPathFile.Directory.FullName == Staging.FullName

				where !Enumerable.Any(
					from _ItemGroup in csproj.Root.Elements(nsItemGroup)
					from _None in _ItemGroup.Elements(nsNone)
					let _Include = _None.Attribute("Include").Value
					where _Include.EndsWith("." + TextComponent)
					let _TargetName = DefaultNamespace + "." + _Include.Replace("/", ".").Replace("\\", ".")
					let _Target = new FileInfo(Path.Combine(Staging.FullName, _TargetName.Substring(DefaultNamespace.Length + 1) + ".dll"))
					where _Target.FullName == HintPathFile.FullName
					select _None
				)
				select new { Reference, HintPathFile }
				)
			{
				// cleanup - do we have any references to staged dll's whose
				// source is no longer available - remove it


				k.Reference.Remove();
				k.HintPathFile.Delete();

				csproj_dirty = true;
			}
			

			
			if (csproj_dirty)
				csproj.Save(this.ProjectFileName.FullName);
		}

		void GenerateAssembly(FileInfo Target, string TargetName, DirectoryInfo Staging, FileInfo[] Sources, Action<AssemblyName> Dirty)
		{
			var name = new AssemblyName(Path.GetFileNameWithoutExtension(Target.Name));


			if (Target.Exists)
				if (Sources.All(s => Target.LastWriteTime > s.LastWriteTime))
				{
					Dirty(name);
					return;
				}



			var a = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave, Staging.FullName);

			#region mark our generated assemblies as script aware
			a.DefineAttribute<ObfuscationAttribute>(
				new { Feature = "script" }
			);
			a.DefineAttribute<CompilerGeneratedAttribute>(new { });
			//a.DefineAttribute<InternalsVisibleToAttribute>( new { AssemblyName = Defaultn});
 
			#endregion


			var m = a.DefineDynamicModule(name.Name, Target.Name);

			foreach (var s in Sources)
			{
				var t = m.DefineType(
					TargetName.Substring(0, TargetName.Length - (TextComponent.Length + 1)), 
					TypeAttributes.Public
				);

				var t_Text = t.DefineField("Text", typeof(string), FieldAttributes.Public | FieldAttributes.InitOnly);

				var t_ctor = t.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, null);

				{
					var il = t_ctor.GetILGenerator();

					il.Emit(OpCodes.Ldarg_0);
					il.Emit(OpCodes.Ldstr, File.ReadAllText(s.FullName));
					il.Emit(OpCodes.Stfld, t_Text);
					il.Emit(OpCodes.Ret);
				}

				t.CreateType();
			}
			


			a.Save(
				Target.Name
			);


			Dirty(name);
		}
	}
}
