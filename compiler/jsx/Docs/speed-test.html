<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><title>JavaScript speed test</title>




  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="speed-test_files/article.css">
  <link rel="stylesheet" type="text/css" href="speed-test_files/speed.css">

  <script type="text/javascript">
	function reschedule(obj, method) {
		setTimeout(function () { obj[method](); }, 0);
	}

	function msecToString(msec) {
		if (msec < 0)
			return "-" + msecToString(-msec);
		var ns = Math.round(msec * 1000000);
		var afterDot = String(1000 + (ns % 1000)).substr(1, 4);
		var beforeDot = Math.floor(ns / 1000);
		return beforeDot + "." + afterDot + "&nbsp;&micro;s";
	}

	function asyncTrial(f, threshold, loopCountStart, ctn) {
		var n = loopCountStart;

		function resume() {
			var t;
			try {
				t = f(n);
			} catch (exc) {
				ctn(null, null, exc);
				return;
			}
			if (t >= threshold) {
				setTimeout(function () { ctn(n, t, null); }, 0);
			} else {
				if (t == 0 && threshold >= 100)
					n *= 100;
				else if (String(n).charAt(0) == '2')
					n = n/2 * 5;
				else
					n *= 2;
				setTimeout(resume, 0);
			}
		}

		resume();
	}

	function sum(a) {
		var t = 0;
		for (var i = 0; i < a.length; i++)
			t += a[i];
		return t;
	}

	function asyncTest(setup, code, threshold, ctn) {
		var body = (
			setup + "\n"
			+ "var _t0 = new Date();\n"
			+ "for (var _i = 0; _i < _n; _i++) {\n"
			+ "\t" + code + "\n"
			+ "}\n"
			+ "var _t1 = new Date();\n"
			+ "return _t1.getTime() - _t0.getTime();"
			);
		try {
			var f = new Function("_n", body);
		} catch (exc) {
			ctn(undefined, exc);
		}

		var nTests = 5;  // must be at least 2
		var a = [];
		var loopCountHint = 1;

		function resume() {
			if (a.length >= nTests) {
				var worst = Math.max.apply(null, a);
				var avg = (sum(a) - worst) / (nTests - 1);
				setTimeout(
					function () { ctn(avg); },
					0);
				return;
			}

			asyncTrial(f, threshold, loopCountHint,
				function (n, dt, error) {
					if (n == null) {
						ctn(null, error);
						return;
					}
					loopCountHint = n;
					a.push(dt/n);
					setTimeout(resume, 0);
				});
		}
		setTimeout(resume, 0);
	}

	// Get the first child of elt with the given tagName, or null.
	function getFirst(elt, tagName) {
		for (var c = elt.firstChild; c != null; c = c.nextSibling) {
			if (c.nodeType == 1 && c.tagName.toLowerCase() == tagName)
				return c;
		}
		return null;
	}

	// Get the next sibling of elt with the same tagName, or null.
	function getNext(elt) {
		for (var s = elt.nextSibling; s != null; s = s.nextSibling) {
			if (s.nodeType == 1 && s.tagName == elt.tagName)
				return s;
		}
		return null;
	}

	function childElements(container) {
		var a = [];
		for (var n = container.firstChild; n !== null; n = n.nextSibling) {
			if (n.nodeType == 1)
				a.push(n);
		}
		return a;
	}

	function elementText(elt) {
		var a = [];
		for (var n = elt.firstChild; n !== null; n = n.nextSibling) {
			if (n.nodeType == 3 || n.nodeType == 4)
				a.push(n.nodeValue);
		}
		return a.join("");
	}

	var splitRegex = /^%%\s*$/m;

	function asyncTestWithCells(testElt, resultElt, threshold, ctn) {
		resultElt.className = "speed-result-processing";
		resultElt.innerHTML = "...";

		var codeNodes = testElt.getElementsByTagName('pre');
		if (codeNodes.length != 1) {
			alert("bug in table: codeNodes.length == " + codeNodes.length);
			this.currentRow = row.nextSibling;
			ctn();
		} else {
			var setup = ""
			var code = elementText(codeNodes[0]);

			var m = splitRegex.exec(code);
			if (m != null) {
				setup = code.substring(0, m.index);
				code = code.substring(m.index + m[0].length, code.length);
			}
			asyncTest(setup, code, threshold,
				function (result, exc) {
					if (result == undefined) {
						resultElt.className = 'speed-result-error';
						resultElt.innerHTML = exc.message;
					} else {
						resultElt.className = 'speed-result';
						resultElt.innerHTML = msecToString(result);
					}
					ctn();
				});
		}
	}

	var g_threshold = 200;

	function tester() {
		this.currentTable = getFirst(document.getElementById("tests"), 'table');
		var tbody = getFirst(this.currentTable, 'tbody');
		this.currentRow = getFirst(tbody, 'tr');
		this.threshold = g_threshold;
	}

	tester.prototype.nextRow = function () {
		var t = this.currentTable;
		if (t == null)
			return false;

		var r = getNext(this.currentRow);
		while (r == null) {
			t = getNext(t);
			if (t == null)
				break;
			var tbody = getFirst(t, 'tbody');
			r = getFirst(tbody, 'tr');
		}

		this.currentTable = t;
		this.currentRow = r;
		return r != null;
	};

	tester.prototype.resume = function () {
		var row = this.currentRow;
		var cells = row.getElementsByTagName('td');
		var testElt = cells[1];
		var resultElt = cells[2];

		var tester = this;
		asyncTestWithCells(testElt, resultElt, this.threshold,
			function () {
				if (tester.nextRow())
					reschedule(tester, "resume");
				else
					alert("Tests finished.");
			});
	};

	function startTests() {
		reschedule(new tester(), "resume");
	}

	function runCell(event) {
		var cell = event.target ? event.target : event.srcElement;
		var p = cell.previousSibling;
		while (true) {
			if (p == null)
				alert("internal error: previous cell not found");
			if (p.nodeType == 1)
				break;
			p = p.previousSibling;
		}
		asyncTestWithCells(p, cell, g_threshold, function () {});
	}

// TODO - always run the empty test and subtract the overhead from everything else
//
// TODO - in IE, use setTimeout to run tests a whole lot of times in
// small batches.  It should capture enough clock ticks to smooth over
// the fact that the individual chunks being measured are so much
// smaller than the clock resolution.  (But then comparisons across
// browsers become suspect.)
//
// TODO - let user tune threshold (initially 200ms)
  </script></head><body>

<div class="breadcrumbs"><a href="http://www.jorendorff.com/">jorendorff.com</a> &gt;
<a href="http://www.jorendorff.com/articles/index.html">Articles</a> &gt;
JavaScript</div>

<h1>JavaScript speed test</h1>

<p>No one should care about JavaScript performance.  But if you do,
this page will help you get a feel for which operations are fast and
which are slow.  For example, you might be surprised to find that
accessing array elements is no faster than accessing object
properties.</p>

<p><strong>How to play.</strong> Double-click any box in the
&#8220;Results&#8221; column to run the test.  Or click the
&#8220;Start tests&#8221; button to run them all; but that takes a
while.  Each test takes 2 or 3 seconds to run.</p>

<p><strong>Details.</strong> How does the tester work?  Why is the
code so convoluted?  Can I depend on the results for my nuclear or
medical application?  All is revealed <a href="#details">below</a>.</p>

<p><strong>Internet Explorer troubleshooting.</strong> In IE, some
tests trigger the infamous &#8220;A script on this page is making
Internet Explorer run slowly&#8221; popup.  This makes the test
results useless.  Fortunately there's a workaround, discovered by <a title="Tony Mills's web page" href="http://amills.net/">Tony Mills</a>.
Just tweak the <a title="Microsoft KB entry for MaxScriptStatements registry setting" href="http://support.microsoft.com/?kbid=175500"><code>MaxScriptStatements</code>
registry setting</a> and IE will totally chill.  Tony writes:
&#8220;The KB entry has an error though. The key is actually
&#8216;<code>Internet&nbsp;Explorer</code>&#8217; not
&#8216;<code>InternetExplorer</code>&#8217;. ...By the way, further
testing revealed that setting the limit to 0 doesn't remove the
message, it just makes IE <em>really</em> annoying. :) So
<code>0xFFFFFFFF</code> is the best value to use.&#8221;</p>



<form>
  <input class="start-tests-button" name="activate" value="Start tests" onclick="this.disabled = true; startTests()" type="button">
</form>


<div id="tests">

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <thead>
    <tr>
      <th>Test</th>
      <th>Code</th>
      <th>Result</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Empty loop</td>
      <td><i>(none)</i><pre></pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
    <tr>
      <td>Custom</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 
 a.do1 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 1); }
 a.do2 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 2); }
 a.do3 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 3); }
 a.do4 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 4); }
 a.do5 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 5); }
 a.do6 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 6); }
 a.do7 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 7); }
 a.do8 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 8); }
 
 // IE: 30, 28
 // FF: 64, 76, 80
 
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>    
<tr>
      <td>Custom</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 
 a.doS = function (c, pa, pb)
 {
    switch (c)
    {
        case 1: { return pa + pb + this.sub(pa - pb + 1); }
        case 2: { return pa + pb + this.sub(pa - pb + 2); }
        case 3: { return pa + pb + this.sub(pa - pb + 3); }
        case 4: { return pa + pb + this.sub(pa - pb + 4); }
        case 5: { return pa + pb + this.sub(pa - pb + 5); }
        case 6: { return pa + pb + this.sub(pa - pb + 6); }
        case 7: { return pa + pb + this.sub(pa - pb + 7); }
        case 8: { return pa + pb + this.sub(pa - pb + 8); }
        default:
            throw null;
    }
 }
 
 // IE: 8
 // FF: 22
 
 
 
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>    
<tr>
      <td>Custom 3</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 

 a.doX = [
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 1); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 2); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 3); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 4); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 5); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 6); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 7); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 8); } 
 ];
 
 // IE 30
 // FF 93, 95, 106
 
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>       
<tr>
      <td>Custom</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 
 a.do1 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 1); }
 a.do2 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 2); }
 a.do3 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 3); }
 a.do4 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 4); }
 a.do5 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 5); }
 a.do6 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 6); }
 a.do7 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 7); }
 a.do8 = function (pa, pb) { return pa + pb + this.sub(pa - pb + 8); }
 
 // IE: 30, 28
 // FF: 64, 76
 
 a.do1(0, 1);
 a.do2(1, 2);
 a.do3(2, 3);
 a.do4(3, 4);
 a.do5(4, 5);
 a.do6(5, 6);
 a.do7(6, 7);
 a.do8(7, 8);
 
 // FF 76, 77
 // IE 72
 
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>   
<tr>
      <td>Custom</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 
 a.doS = function (c, pa, pb)
 {
    switch (c)
    {
        case 1: { return pa + pb + this.sub(pa - pb + 1); }
        case 2: { return pa + pb + this.sub(pa - pb + 2); }
        case 3: { return pa + pb + this.sub(pa - pb + 3); }
        case 4: { return pa + pb + this.sub(pa - pb + 4); }
        case 5: { return pa + pb + this.sub(pa - pb + 5); }
        case 6: { return pa + pb + this.sub(pa - pb + 6); }
        case 7: { return pa + pb + this.sub(pa - pb + 7); }
        case 8: { return pa + pb + this.sub(pa - pb + 8); }
        default:
            throw null;
    }
 }
 
 // IE: 8
 // FF: 22
 
 a.doS(1, 0, 1);
 a.doS(2, 1, 2);
 a.doS(3, 2, 3);
 a.doS(4, 3, 4);
 a.doS(5, 4, 5);
 a.doS(6, 5, 6);
 a.doS(7, 6, 7);
 a.doS(8, 7, 8);
 
 // FF 39, 44
 // IE 55, 56
 
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>    
<tr>
      <td>Custom 3</td>
      <td><pre>
 var a = {
    value : 4,
    sub : function (i)
    {
        return i - this.value;
    }
  };
 

 a.doX = [
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 1); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 2); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 3); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 4); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 5); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 6); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 7); },
     function (t, pa, pb) { return pa + pb + t.sub(pa - pb + 8); } 
 ];
 
 // IE 30
 // FF 93, 95, 106
 
 a.doX[0](a, 0, 1);
 a.doX[1](a,1, 2);
 a.doX[2](a,2, 3);
 a.doX[3](a,3, 4);
 a.doX[4](a,4, 5);
 a.doX[5](a,5, 6);
 a.doX[6](a,6, 7);
 a.doX[7](a,7, 8);
  
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>    
<tr>
      <td>Custom</td>
      <td><pre>
      var f = function () {};
      var i = 0;
      
      var z = function (w, i)
      {
         if (i == 0 ||
             i == 1 ||
             i == 3 ||
             i == 4)
         {
            f();
         }
         
      }
      
      f = null;
      z = null;
      
      
      // 22 - 21.025 µs
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>      
<tr>
      <td>Custom</td>
      <td><pre>
      var f = function () {};
      var i = 0;
      
      var z = function (w, i)
      {
        switch (i)
        {
            case 0:
            case 1:
            case 3:
            case 4:
                f();
                break;
        }
                  
      }
      
      f = null;
      z = null;
      
      // 7.960 µs
       
          </pre></td><td ondblclick="runCell(event)"></td>
    </tr>               
  </tbody>
</table>


<h2>Variables</h2>

<p>These tests compare the performance of local, global, and closure
variables.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Create local variable</td>
      <td><pre>var x;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create 10 local variables</td>
      <td><pre>var x1, x2, x3, x4, x5, x6, x7, x8, x9, x10;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create and initialize local variable</td>
      <td><pre>var x = 13;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Increment local</td>
      <td><pre>var i = 0;
%%
i++;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access local</td>
      <td><pre>var _test_value = 123;
%%
_test_value;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access global</td>
      <td><pre>window._test_value = 123;
%%
_test_value;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access variable in closure</td>
      <td><pre>function makeFn(n) {
	return function() {
		var nTests = _n;
		for (var i = 0; i &lt; nTests; i++)
			n;
	}
};
var runTest = makeFn(123);
%%
runTest();
break;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Assign local</td>
      <td><pre>var _test_value;
%%
_test_value = 123;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Assign global</td>
      <td><pre>window._test_value = 123;
%%
_test_value = 123;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Assign to variable in closure</td>
      <td><pre>function makeFn(n) {
	return function() {
		var nTests = _n;
		for (var i = 0; i &lt; nTests; i++)
			n = 123;
	}
};
var runTest = makeFn(123);
%%
runTest();
break;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Calling functions</h2>

<p>On my machine, function calls are several times faster in Mozilla
than in IE.</p>

<p>Calling a global function is slower than calling a local function,
but only because of the name lookup.</p>

<p>In IE, the last test here consistently runs about 5% faster than
the very similar one immediately preceding it.  No idea why.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Call locally defined function</td>
      <td><pre>function f() {}
%%
f();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Call locally created anonymous function</td>
      <td><pre>var f1 = function () {};
%%
f1();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Call global function</td>
      <td><pre>window.f1 = new Function("");
%%
f1();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Call function created with <code>new Function</code></td>
      <td><pre>var f5 = new Function ("");
%%
f5();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Call global function via local alias</td>
      <td><pre>window.f6 = new Function("");
var f6local = f6;
%%
f6local();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>

<h2>Creating functions</h2>

<p>In Mozilla, a function expression without a name runs twice as fast
as one with a name.</p>

<p>In IE, defining a local function takes no time at all.  The local
function is created as soon as the function is called, and it is not
re-created each time the test loop runs.  So the test loop is
essentially empty.  In Mozilla, a new function object is created each
time through the loop.</p>

<p>A call to <code>new Function</code> is slower than a function
expression, presumably because it has to compile the code.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

    <tbody><tr>
      <td>Define local function</td>
      <td><pre>function f() {}</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create function using function expression without name</td>
      <td><pre>var f;
%%
f = function () {};</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create function using function expression with name</td>
      <td><pre>var f;
%%
f = function jane() {};</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create function using <code>Function</code> constructor</td>
      <td><pre>var f;
%%
f = new Function("");</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create nonempty function</td>
      <td><pre>var f;
%%
f = function elementText(elt) {
		var a = [];
		for (var n = elt.firstChild;
			n !== null;
			n = n.nextSibling)
		{
			if (n.nodeType == 3 || n.nodeType == 4)
				a.push(n.nodeValue);
		}
		return a.join("");
	};
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create deeply nested function</td>
      <td><pre>var a = ["var myfn = function () { "];
for (var i = 0; i &lt; 500; i++)
	a.push("return function () { ");
a.push("return null;");
for (var i = 0; i &lt; 500; i++)
	a.push(" };");
a.push("}; myfn");
var makeFn = eval(a.join(""));
var f;
%%
f = makeFn();
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Arrays</h2>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Create empty array</td>
      <td><pre>([]);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create small array</td>
      <td><pre>([1, 2, 3]);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create small array and local variable</td>
      <td><pre>var a = [1, 2, 3];</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access elements by index</td>
      <td><pre>var a = [1, 2, 3, 4, 5];
%%
a[3]</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 10-element array using element assignment</td>
      <td><pre>var a;
%%
a = [];
for (var i = 0; i &lt; 10; i++)
	a[i] = i;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 10-element array using <code>push()</code></td>
      <td><pre>var a;
%%
a = [];
for (var i = 0; i &lt; 10; i++)
	a.push(i);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 1000-element array of numbers using element assignment</td>
      <td><pre>var a;
%%
a = [];
for (var i = 0; i &lt; 1000; i++)
	a[i] = i;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 1000-element array of numbers using <code>push()</code></td>
      <td><pre>var a;
%%
a = [];
for (var i = 0; i &lt; 1000; i++)
	a.push(i);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 1000-element array of objects using <code>push()</code></td>
      <td><pre>var a;
var x = {};
%%
a = [];
for (var i = 0; i &lt; 1000; i++)
	a.push(x);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Pop</td>
      <td><pre>var arrays = [];
for (var i = 0; i &lt; _n; i++) {
	var a = [];
	for (j = 0; j &lt; 1000; j++)
		a[j] = j;
	arrays[i] = a;
}
%%
var a = arrays[_i];
for (var i = 0; i &lt; 1000; i++)
	a.pop();</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<p>Maintaining the length of an array in a separate variable can make
stack operations several times faster.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>1000 <code>push()</code> and <code>pop()</code> calls interleaved</td>
      <td><pre>var a = [];
%%
for (var i = 0; i &lt; 100; i++) {
	a.push(17);
	a.push(19);
	a.push(31);
	a.pop();
	a.push(83);
	a.push(7);
	a.pop();
	a.pop();
	a.pop();
	a.pop();
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>1000 <code>a[len++]=</code> and <code>a[--len]</code> operations interleaved</td>
      <td><pre>var a = [];
var len = 0;
%%
for (var i = 0; i &lt; 100; i++) {
	a[len++] = 17;
	a[len++] = 19;
	a[len++] = 31;
	a[--len];
	a[len++] = 83;
	a[len++] = 7;
	a[--len];
	a[--len];
	a[--len];
	a[--len];
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Objects</h2>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Create empty object</td>
      <td><pre>({});</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create empty object and local variable</td>
      <td><pre>var x = {};</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 1000 numbered properties</td>
      <td><pre>var x;
%%
x = {};
for (var i = 0; i &lt; 1000; i++)
	x[i] = i;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Populate 1000 numbered properties with object</td>
      <td><pre>var x;
var y = {};
%%
x = {};
for (var i = 0; i &lt; 1000; i++)
	x[i] = y;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Object type-checking</h2>

<p><code>Object.isPrototypeOf()</code> is slow: 2-3 times
slower than a simple attribute test.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Object.isPrototypeOf() when true</td>
      <td><pre>function writer() {}
var x = new writer();
%%
if (writer.prototype.isPrototypeOf(x)) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Attribute test when true</td>
      <td><pre>function writer() {}
writer.prototype.isWriter = true;
var x = new writer();
%%
if (x.isWriter) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Object.isPrototypeOf() when trivially false</td>
      <td><pre>function writer() {}
var x = {};
%%
if (writer.prototype.isPrototypeOf(x)) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Attribute test when trivially false</td>
      <td><pre>var x = {
	make: 'Ford', model: 'Taurus',
	year: 1996, color: '#000066'};
%%
if (x.isWriter) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Object.isPrototypeOf() when elaborately false</td>
      <td><pre>function writer() {}
function reader() {}
function http_reader() {}
http_reader.prototype = new reader();
http_reader.prototype.constructor = http_reader;
var x = new http_reader();
%%
if (writer.prototype.isPrototypeOf(x)) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>


    <tr>
      <td>Attribute test when elaborately false</td>
      <td><pre>function writer() {}
writer.prototype.isWriter = true;

function reader() {}
function http_reader() {}
http_reader.prototype = new reader();
http_reader.prototype.constructor = http_reader;
var x = new http_reader();
%%
if (x.isWriter) {
	// ...
} else {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>





<h2>Data structures</h2>

<p>What's the fastest possible way to build and access data structures
in JavaScript?</p>

<p>Objects and arrays are about equally fast.  Using closures to store
data (a trick from functional programming) is slower.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Create 2-property object</td>
      <td><pre>var nil = {};
var cell;
%%
cell = {car: nil, cdr: nil};</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create 2-property object using <code>new</code></td>
      <td><pre>var nil = {};
function pair(a, b) {
	this.car = a;
	this.cdr = b;
}
var cell;
%%
cell = new pair(nil, nil);</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create 2-element array</td>
      <td><pre>var nil = {};
var cell;
%%
cell = [nil, nil];
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Create closure on 2 values</td>
      <td><pre>var nil = {};
var cell;
var a = nil;
var b = nil;
%%
cell = function (t) { return t ? a : b; };
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access object properties</td>
      <td><pre>var nil = {};
var cell = {car: nil, cdr: nil};
%%
cell.cdr;</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access array elements</td>
      <td><pre>var nil = {};
var cell = [nil, nil];
%%
cell[1];
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Access data hidden in closure</td>
      <td><pre>function cons(a, b) {
	return function(t) {
		return t ? a : b;
	}
}
var nil = {};
var cell = cons(nil, nil);
%%
cell(false);
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Assign object properties</td>
      <td><pre>var nil = {};
var cell = {car: nil, cdr: nil};
%%
cell.cdr = 123;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Assign array elements</td>
      <td><pre>var nil = {};
var cell = [nil, nil];
%%
cell[1] = 123;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>


<h2><code>if</code> and <code>switch</code></h2>

<p>On my machine, a <code>switch</code> statement with five cases is
twice as fast as an <code>if</code> statement with five branches.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td><code>if</code> comparing small integers, hitting the first</td>
      <td><pre>var x = 0;
%%
if (x == 0) {
	// ...
} else if (x == 1) {
	// ...
} else if (x == 2) {
	// ...
} else if (x == 3) {
	// ...
} else if (x == 4) {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>switch</code> on small integers, hitting the first</td>
      <td><pre>var x = 0;
%%
switch (x) {
	case 0: break;
	case 1: break;
	case 2: break;
	case 3: break;
	case 4: break;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>if</code> comparing small integers, hitting the last</td>
      <td><pre>var x = 4;
%%
if (x == 0) {
	// ...
} else if (x == 1) {
	// ...
} else if (x == 2) {
	// ...
} else if (x == 3) {
	// ...
} else if (x == 4) {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>switch</code> on small integers, hitting the last</td>
      <td><pre>var x = 4;
switch (x) {
	case 0: break;
	case 1: break;
	case 2: break;
	case 3: break;
	case 4: break;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>if</code> missing everything</td>
      <td><pre>var x = 4;
%%
if (x == 61) {
	// ...
} else if (x == 312) {
	// ...
} else if (x == 928) {
	// ...
} else if (x == 1003) {
	// ...
} else if (x == 5778) {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>switch</code> missing everything</td>
      <td><pre>var x = 4;
%%
switch (x) {
	case 61:   break;
	case 312:  break;
	case 928:  break;
	case 1003: break;
	case 5778: break;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>if</code> comparing characters, missing everything</td>
      <td><pre>var c = 'e';
%%
if (c == '\n') {
	// ...
} else if (c == 'y') {
	// ...
} else if (c == 'n') {
	// ...
} else if (c == 'q') {
	// ...
} else if (c == 'a') {
	// ...
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>switch</code> on characters, missing everything</td>
      <td><pre>var c = 'e';
%%
switch (c) {
	case '\n': break;
	case 'y':  break;
	case 'n':  break;
	case 'q':  break;
	case 'a':  break;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Dynamic dispatch</h2>

<p>What's the fastest way to execute different code depending on the
value of a string variable?  <code>switch</code> is the fastest.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td><code>if</code></td>
      <td><pre>var x = false;
var s = 'five';
%%
if (s == 'one') { x=true; }
else if (s == 'two') { x=true; }
else if (s == 'three') { x=true; }
else if (s == 'four') { x=true; }
else if (s == 'five') { x=true; }
else if (s == 'six') { x=true; }
else if (s == 'seven') { x=true; }
else if (s == 'eight') { x=true; }
else if (s == 'nine') { x=true; }
else if (s == 'ten') { x=true; }
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>switch</code></td>
      <td><pre>var x = false;
var s = 'five';
%%
switch (s) {
case 'one': x=true; break;
case 'two': x=true; break;
case 'three': x=true; break;
case 'four': x=true; break;
case 'five': x=true; break;
case 'six': x=true; break;
case 'seven': x=true; break;
case 'eight': x=true; break;
case 'nine': x=true; break;
case 'ten': x=true; break;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>lookup table of functions</td>
      <td><pre>var x = false;
var obj = {
	one: function () { x=true; },
	two: function () { x=true; },
	three: function () { x=true; },
	four: function () { x=true; },
	five: function () { x=true; },
	six: function () { x=true; },
	seven: function () { x=true; },
	eight: function () { x=true; },
	nine: function () { x=true; },
	ten: function () { x=true; }
};
var s = 'five';
%%
obj[s]();
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>


<h2>Loops</h2>

<p>There's no speed difference between <code>++c</code> and
<code>c++</code> in a <code>for</code> loop.</p>

<p>All these should be equally fast.  In Mozilla, the <code>for</code>
loop is just a hair faster than <code>while</code>; no clue why.  And
<code>do/while</code> is 5-10% faster still; I have no idea what
that's all about.</p>

<p>The <code>do/while</code> test triggers IE's &#8220;run
slowly&#8221; message on my machine; the others don't.  Bizarre.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td><code>for</code> up to 100</td>
      <td><pre>var c;
%%
for (c = 0; c &lt; 100; c++) {
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>for</code> up to 100, preincrement</td>
      <td><pre>var c;
%%
for (c = 0; c &lt; 100; ++c) {
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>while</code> up to 100</td>
      <td><pre>var c;
%%
c = 0;
while (c &lt; 100) {
	c++;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td><code>do/while</code> up to 100</td>
      <td><pre>var c;
%%
c = 0;
do {
	c++;
} while (c &lt; 100);
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>


<h2>Whitespace</h2>

<p>Whitespace in source code doesn't affect speed.</p>

<p>(Whitespace affects running code in at least one way: when an error
happens, the system tries to tell you what line of code it happened
on.  Some scripting languages used to implement this using an internal
line-number counter, which was incremented at the beginning of every
line of code.  The line-number counting could actually affect
performance in a tight loop.  I don't know of any major languages that
still do this.)</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>

    <tr>
      <td>on one line</td>
      <td><pre>var i = 0;
%%
i = Number(i); i++; i++; i++; i++; i++; i++; i++; i++; i++; i++;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>on multiple lines</td>
      <td><pre>var i = 0;
%%
i = Number(i);
i++;
i++;
i++;
i++;
i++;
i++;
i++;
i++;
i++;
i++;
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>


<h2>Text processing</h2>

<p>What is the fastest way to tell whether a given character
<code>c</code> is one of a particular known set of characters?</p>

<p>Interesting results.  Almost all of these are dog slow in
Mozilla.  Except the last one.</p>

<p>In IE, the last option is three times faster than the rest.  In
Mozilla, it's ten times faster.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Character testing: longhand</td>
      <td><pre>var c = '(';
var hits = 0;
%%
if (c.length == 1 &amp;&amp; (
	(c &gt;= 'a' &amp;&amp; c &lt;= 'z')
	|| (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
	|| (c &gt;= '0' &amp;&amp; c &lt;= '9')
	|| c == '-')) {}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Character testing: by character code</td>
      <td><pre>var c = '(';
var hits = 0;
%%
var i = c.charCodeAt(0);
if ((i &gt;= 97 &amp;&amp; i &lt;= 122)
	|| (i &gt;= 65 &amp;&amp; i &lt;= 90)
	|| (i &gt;= 48 &amp;&amp; i &lt;= 57)
	|| i == 45) {}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Character testing: with <code>String.indexOf()</code></td>
      <td><pre>var w = ("abcdefghijklmnopqrstuvwxyz"
	+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-");
var c = '(';
%%
if (w.indexOf(c) != -1) {}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Character testing: with regular expression</td>
      <td><pre>var wx = /[a-zA-Z0-9-]/;
var c = '(';
var hits = 0;
%%
if (c.match(wx) !== null) {}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Character testing: by hashtable</td>
      <td><pre>var c = '(';
var w = ("abcdefghijklmnopqrstuvwxyz"
	+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-");
var whash = {};
for (var i = 0; i &lt; w.length; i++)
	whash[w.charAt(i)] = true;
var hits = 0;
%%
if (whash[c]) {}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

  </tbody>
</table>


<p>For more complex parsing, regular expressions are 20-50 times
faster than a hand-coded parse routine.</p>

<table class="speed">
  <col class="speed-name">
  <col class="speed-code">
  <col class="speed-result">

  <tbody>
    <tr>
      <td>Parsing: with sloppy regular expression</td>
      <td><pre>var text = document.documentElement.innerHTML;
var regex = /&lt;([\w-]+)/g;
var matchArray;
var match;
var count = 0;
%%
while ((matchArray = regex.exec(text)) !== null) {
	match = matchArray[1];
	count++;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>

    <tr>
      <td>Parsing: with sloppy hand-coded loop</td>
      <td><pre>var text = document.documentElement.innerHTML;
var i;
var match;
var count = 0;
var tagNameChars = (
	'abcdefghijklmnopqrstuvwxyz'
	+ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-');
%%
i = 0;
while (i &lt; text.length) {
	// search for angle bracket
	while (i &lt; text.length &amp;&amp; text.charAt(i) != '&lt;')
		i++;
	if (++i &gt;= text.length)
		break;

	var c = text.charAt(i);
	if (tagNameChars.indexOf(c) == -1)
		continue;

	var b = i;
	while (++i &lt; text.length
		&amp;&amp; tagNameChars.indexOf(text.charAt(i)) != -1)
		;
	match = text.substring(b, i);
	count++;
}
</pre></td>
      <td ondblclick="runCell(event)"></td>
    </tr>
  </tbody>
</table>



<div id="details">

<h2>Details</h2>

  <p><strong>Overhead.</strong> All results include the overhead of a
  simple <code>for</code> loop; run the &#8220;Empty loop&#8221; test to
  see how much this is.</p>

  <p><strong>Accuracy.</strong>  Forget it.  The results are very noisy.
  Double-click any cell two or three times and you'll get different
  results.  I imagine you can get maybe one significant digit out of
  these, maybe a bit less.</p>

  <p><strong>How it works.</strong> For each test, the tester uses
  <code>new Function()</code> to create a function that takes a positive
  whole number <var>N</var> and times the execution of the test code
  <var>N</var> times in a tight loop.  Then it calls the function
  repeatedly, with <var>N</var>=1, then 2, then 5, 10, 20, 50, and so on
  until the loop actually takes a significant amount of time to execute
  (at least 200ms).  It does this 5 times, throws out the worst time,
  and averages the other four.  This average is what's displayed.</p>

  <p>The tester code is written in continuation-passing style, an
  extremely weird way to program that helps to avoid triggering the
  infamous &#8220;A script on this page is making Internet Explorer run
  slowly&#8221; popup.  Alas, this message pops up on the
  fastest tests regardless, unless you use the workaround described at
  the top of the page.</p>

</div>

</div></body></html>